
==================== FINAL INTERFACE ====================
2019-03-24 00:41:37.357790108 UTC

interface main:Cipher 8064
  interface hash: 15f72d3f70264ffece76648677014c94
  ABI hash: b4aac5e70f1d065ef801d8c3e3e07065
  export-list hash: 8f1d9a3cd2d66fd290d2343da8879cf3
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: cb7427e4245f09bb4d5f2aa80ef7197d
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Cipher.caesar
  Cipher.decode
  Cipher.encode
  Cipher.main
  Cipher.shift
  Cipher.shiftLeftUppercase
  Cipher.shiftRightUppercase
  Cipher.shiftUppercase
  Cipher.ShiftFunction
module dependencies:
package dependencies: base-4.12.0.0* ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity base-4.12.0.0:Data.Monoid
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:GHC.Generics
                         base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:Data.Char 74f67fe9150a102afa18766e840f6832
import  -/  base-4.12.0.0:Data.Foldable 5f70351366640f007be66681d2212df8
import  -/  base-4.12.0.0:Data.OldList e931cf456dc87f11ee6e6fb153bca23e
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Char 5cf05c9d27b9979e6c5b3566c8a985f5
import  -/  base-4.12.0.0:GHC.Err ea5e313ef4146b40b5d8b27aa168e736
import  -/  base-4.12.0.0:GHC.IO.Handle fe51659cf05ea3ecd36fe5e2d515d89a
import  -/  base-4.12.0.0:GHC.IO.Handle.FD 57dd508e0260edfe7dfb9592eb9a6e63
import  -/  base-4.12.0.0:GHC.IO.Handle.Types 8909e00409cd23d4e66395a7e93f216d
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:GHC.Real af2b985dd29515c375fb78b2c9298d42
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  base-4.12.0.0:System.IO dd4f3cfe73b94b7cae46a4ca98a3f09f
import  -/  base-4.12.0.0:Text.Read 87f80fc2538a174aea915dd98f74fc0a
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
5dc186cadbae49e8bcaea7aa6f90604d
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Cipher.$trModule3
                   Cipher.$trModule1) -}
12bb90b5da5d97180beaf7eef03f5d98
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Cipher.$trModule2) -}
afb523d45b12a0fb8631c3972447bb23
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Cipher"#) -}
72170614b5b71b0fbac5fb1d5300215e
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Cipher.$trModule4) -}
b2d711cd7637a9fefe2afa8b2a410017
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
4091c79ef02fbb36838bde907e624dbd
  type ShiftFunction =
    GHC.Types.Int -> GHC.Types.Char -> GHC.Types.Char
8a6fda3dcdb85231047198a108ab4c85
  caesar ::
    Cipher.ShiftFunction
    -> GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(C(U))><L,U>,
     Unfolding: (\ (shiftFunction :: Cipher.ShiftFunction)
                   (amount :: GHC.Types.Int) ->
                 let {
                   f :: GHC.Types.Char -> GHC.Types.Char = shiftFunction amount
                 } in
                 letrec {
                   go :: [GHC.Types.Char] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (s :: [GHC.Types.Char]) ->
                     case GHC.List.dropWhile
                            @ GHC.Types.Char
                            GHC.Unicode.isSpace
                            s of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : ipv ipv1
                       -> GHC.Types.:
                            @ GHC.Types.Char
                            Cipher.caesar1
                            (case GHC.List.$wbreak
                                    @ GHC.Types.Char
                                    GHC.Unicode.isSpace
                                    wild of ww { (#,#) ww1 ww2 ->
                             GHC.Base.++
                               @ GHC.Types.Char
                               (GHC.Base.map @ GHC.Types.Char @ GHC.Types.Char f ww1)
                               (go ww2) }) }
                 } in
                 \ (x :: GHC.Base.String) ->
                 case go x of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char : ds1 xs -> xs }) -}
213d477fa04825643118489fcb1edc4f
  caesar1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' '#) -}
84b9c03081ce934b66abb764dd3e1c61
  decode :: GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: (\ (amount :: GHC.Types.Int) ->
                 let {
                   f :: GHC.Types.Char -> GHC.Types.Char
                   = Cipher.shift
                       Cipher.decode1
                       (case amount of wild { GHC.Types.I# x ->
                        GHC.Types.I# (GHC.Prim.negateInt# x) })
                 } in
                 letrec {
                   go :: [GHC.Types.Char] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (s :: [GHC.Types.Char]) ->
                     case GHC.List.dropWhile
                            @ GHC.Types.Char
                            GHC.Unicode.isSpace
                            s of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : ipv ipv1
                       -> GHC.Types.:
                            @ GHC.Types.Char
                            Cipher.caesar1
                            (case GHC.List.$wbreak
                                    @ GHC.Types.Char
                                    GHC.Unicode.isSpace
                                    wild of ww { (#,#) ww1 ww2 ->
                             GHC.Base.++
                               @ GHC.Types.Char
                               (GHC.Base.map @ GHC.Types.Char @ GHC.Types.Char f ww1)
                               (go ww2) }) }
                 } in
                 \ (x :: GHC.Base.String) ->
                 case go x of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char : ds1 xs -> xs }) -}
8cdbd9ac317734b6d1daa01ce4495736
  decode1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Enum.eftChar 65# 90#) -}
9477c746c9ea56407ce7dc83173a5d77
  encode :: GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U(U)>,
     Unfolding: (\ (amount :: GHC.Types.Int) ->
                 let {
                   f :: GHC.Types.Char -> GHC.Types.Char
                   = Cipher.shift Cipher.decode1 amount
                 } in
                 letrec {
                   go :: [GHC.Types.Char] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (s :: [GHC.Types.Char]) ->
                     case GHC.List.dropWhile
                            @ GHC.Types.Char
                            GHC.Unicode.isSpace
                            s of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : ipv ipv1
                       -> GHC.Types.:
                            @ GHC.Types.Char
                            Cipher.caesar1
                            (case GHC.List.$wbreak
                                    @ GHC.Types.Char
                                    GHC.Unicode.isSpace
                                    wild of ww { (#,#) ww1 ww2 ->
                             GHC.Base.++
                               @ GHC.Types.Char
                               (GHC.Base.map @ GHC.Types.Char @ GHC.Types.Char f ww1)
                               (go ww2) }) }
                 } in
                 \ (x :: GHC.Base.String) ->
                 case go x of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char : ds1 xs -> xs }) -}
ad7ffdd282bd470c28aae3c60a2f3455
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Cipher.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
f0305f3b2945d958917d38886d1076b7
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U> -}
182ad47132622fe4a20657cb94bf858e
  shift :: GHC.Base.String -> Cipher.ShiftFunction
  {- Arity: 2, Strictness: <L,U><L,U(U)>,
     Unfolding: (\ (set :: GHC.Base.String) (amount :: GHC.Types.Int) ->
                 let {
                   origin :: GHC.Types.Int
                   = case set of wild {
                       [] -> case GHC.List.badHead ret_ty GHC.Types.Int of {}
                       : x ds1
                       -> case x of wild1 { GHC.Types.C# c# ->
                          GHC.Types.I# (GHC.Prim.ord# c#) } }
                 } in
                 let {
                   ds :: GHC.Types.Int
                   = case GHC.List.$wlenAcc
                            @ GHC.Types.Char
                            set
                            0# of ww2 { DEFAULT ->
                     GHC.Types.I# ww2 }
                 } in
                 \ (x :: GHC.Types.Char) ->
                 case origin of wild { GHC.Types.I# x1 ->
                 case ds of ww { GHC.Types.I# ww1 ->
                 case ww1 of wild1 {
                   DEFAULT
                   -> case x of wild2 { GHC.Types.C# c# ->
                      case amount of wild3 { GHC.Types.I# y ->
                      case GHC.Classes.modInt#
                             (GHC.Prim.+# (GHC.Prim.-# (GHC.Prim.ord# c#) x1) y)
                             wild1 of ww2 { DEFAULT ->
                      let {
                        i# :: GHC.Prim.Int# = GHC.Prim.+# x1 ww2
                      } in
                      case GHC.Prim.leWord# (GHC.Prim.int2Word# i#) 1114111## of lwild {
                        DEFAULT -> GHC.Char.$wlvl i#
                        1# -> GHC.Types.C# (GHC.Prim.chr# i#) } } } }
                   -1#
                   -> case GHC.Prim.leWord#
                             (GHC.Prim.int2Word# x1)
                             1114111## of lwild {
                        DEFAULT -> GHC.Char.$wlvl x1
                        1# -> GHC.Types.C# (GHC.Prim.chr# x1) }
                   0#
                   -> case GHC.Real.divZeroError ret_ty GHC.Types.Char of {} } } }) -}
f9847708dfa36330bdbfebecf3c2857b
  shiftLeftUppercase :: Cipher.ShiftFunction
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Types.Int) ->
                 Cipher.shift
                   Cipher.decode1
                   (case x of wild { GHC.Types.I# x1 ->
                    GHC.Types.I# (GHC.Prim.negateInt# x1) })) -}
92b44fac1d9e8defaff1161c97db3f8d
  shiftRightUppercase :: Cipher.ShiftFunction
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True) Cipher.shiftUppercase -}
2ff33863ab4269bd92ffa788423a5956
  shiftUppercase :: Cipher.ShiftFunction
  {- Arity: 1, Unfolding: (Cipher.shift Cipher.decode1) -}
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

